/**
 * The types here are hand copied from peggy's peg.d.ts file so that end
 * consumers of the GLSL parser can use the error type without me having to
 * fully publish peggy as a dependency of this module.
 *
 * The primary exported type is GlslSyntaxError.
 */

/** Provides information pointing to a location within a source. */
export interface Location {
  /** Line in the parsed source (1-based). */
  line: number;
  /** Column in the parsed source (1-based). */
  column: number;
  /** Offset in the parsed source (0-based). */
  offset: number;
}

/** The `start` and `end` position's of an object within the source. */
export interface LocationRange {
  /** Any object that was supplied to the `parse()` call as the `grammarSource` option. */
  source: any;
  /** Position at the beginning of the expression. */
  start: Location;
  /** Position after the end of the expression. */
  end: Location;
}

/** Specific sequence of symbols is expected in the parsed source. */
interface LiteralExpectation {
  type: 'literal';
  /** Expected sequence of symbols. */
  text: string;
  /** If `true`, symbols of any case is expected. `text` in that case in lower case */
  ignoreCase: boolean;
}

/** One of the specified symbols is expected in the parse position. */
interface ClassExpectation {
  type: 'class';
  /** List of symbols and symbol ranges expected in the parse position. */
  parts: (string[] | string)[];
  /**
   * If `true`, meaning of `parts` is inverted: symbols that NOT expected in
   * the parse position.
   */
  inverted: boolean;
  /** If `true`, symbols of any case is expected. `text` in that case in lower case */
  ignoreCase: boolean;
}

/** Any symbol is expected in the parse position. */
interface AnyExpectation {
  type: 'any';
}

/** EOF is expected in the parse position. */
interface EndExpectation {
  type: 'end';
}

/**
 * Something other is expected in the parse position. That expectation is
 * generated by call of the `expected()` function in the parser code, as
 * well as rules with human-readable names.
 */
interface OtherExpectation {
  type: 'other';
  /**
   * Depending on the origin of this expectation, can be:
   * - text, supplied to the `expected()` function
   * - human-readable name of the rule
   */
  description: string;
}

type Expectation =
  | LiteralExpectation
  | ClassExpectation
  | AnyExpectation
  | EndExpectation
  | OtherExpectation;

/**
 * The entry that maps object in the `source` property of error locations
 * to the actual source text of a grammar. That entries is necessary for
 * formatting errors.
 */
export interface SourceText {
  /**
   * Identifier of a grammar that stored in the `location().source` property
   * of error and diagnostic messages.
   *
   * This one should be the same object that used in the `location().source`,
   * because their compared using `===`.
   */
  source: any;
  /** Source text of a grammar. */
  text: string;
}

export interface SyntaxError extends Error {
  /** Location where error was originated. */
  location: LocationRange;
  /**
   * List of possible tokens in the parse position, or `null` if error was
   * created by the `error()` call.
   */
  expected: Expectation[] | null;
  /**
   * Character in the current parse position, or `null` if error was created
   * by the `error()` call.
   */
  found: string | null;

  /**
   * Format the error with associated sources.  The `location.source` should have
   * a `toString()` representation in order the result to look nice. If source
   * is `null` or `undefined`, it is skipped from the output
   *
   * Sample output:
   * ```
   * Error: Expected "!", "$", "&", "(", ".", "@", character class, comment, end of line, identifier, literal, or whitespace but "#" found.
   *  --> my grammar:3:9
   *   |
   * 3 | start = # 'a';
   *   |         ^
   * ```
   *
   * @param sources mapping from location source to source text
   *
   * @returns the formatted error
   */
  format(sources: SourceText[]): string;
}

/**
 * Peggy's default error type is complete nonsense. It has the horrific
 * format() API to get a useful error message.
 */
export class GlslSyntaxError extends Error {
  /** Location where error was originated. */
  location: LocationRange;

  /**
   * List of possible tokens in the parse position, or `null` if error was
   * created by the `error()` call.
   */
  expected: Expectation[] | null;
  /**
   * Character in the current parse position, or `null` if error was created
   * by the `error()` call.
   */
  found: string | null;

  constructor(source: string, grammarSource: string, error: SyntaxError) {
    // End users shouldn't have to deal with this - this line is the main
    // purpose of this class. #format() is what gives an ASCII formatted error
    // message with ASCII arrows pointing to the location of the source. For
    // example, this format method produces something like
    //     Error: Expected end of input but "#" found.
    //     --> location:3:5
    //     |
    //     3 |     #ifdef RENORMALZE_REFLECTANCE
    //     |     ^
    super(error.format([{ source: grammarSource, text: source }]));
    this.location = error.location;
    this.expected = error.expected;
    this.found = error.found;
  }
}

// When the error is formatted, this is the string that shows before the
// location text. For example this becomes "location:3:5".
export const DEFAULT_GRAMMAR_SOURCE = 'location';

/**
 * Wrap the peggy parser to catch the built in SyntaxError and throw a
 * formatted GlslSyntaxError instead.
 */
export const formatError = <
  T extends {
    parse: (...args: any[]) => any;
    SyntaxError: new () => SyntaxError;
  }
>(
  parser: T,
  grammarSource = DEFAULT_GRAMMAR_SOURCE
  // Some gymanastics to forward the return type of the parser so the exported
  // parse() function has the right types
): T['parse'] => (...args: Parameters<T['parse']>) => {
  const [src, options] = args;
  try {
    return parser.parse(src, {
      grammarSource,
      ...options,
    });
  } catch (e) {
    if (e instanceof parser.SyntaxError) {
      throw new GlslSyntaxError(src, grammarSource, e as SyntaxError);
    }
    throw e;
  }
};
